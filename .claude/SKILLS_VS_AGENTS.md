# Skills vs Agents vs Commands：使用场景指南

## 核心区别

### Skills（技能）
**本质**：知识库 + 上下文增强器  
**作用**：在开发过程中提供**实时指导和最佳实践**  
**特点**：自动激活、被动提供、持续存在

### Agents（代理）
**本质**：自主任务执行器  
**作用**：**自主执行复杂任务**并返回结果  
**特点**：按需调用、主动执行、任务完成即结束

### Commands（斜杠命令）
**本质**：结构化工作流模板  
**作用**：**生成持久化文档**用于任务规划和跟踪  
**特点**：斜杠触发、生成文件、跨会话持久化

---

## 本质区别对比

| 维度 | Skills | Agents | Commands |
|------|--------|--------|----------|
| **角色定位** | 导师/顾问 | 执行者/专家 | 规划师/记录员 |
| **工作方式** | 被动提供建议 | 主动执行任务 | 生成结构化文档 |
| **触发方式** | 自动（通过 hooks） | 手动调用（Task 工具） | 斜杠命令（`/command`） |
| **存在时间** | 整个会话中持续存在 | 任务完成后消失 | 文档持久化到文件系统 |
| **输出形式** | 代码建议、模式示例 | 完整的分析报告、修复结果 | 文档文件（plan.md, context.md, tasks.md） |
| **交互方式** | 你写代码，它提供建议 | 你描述任务，它执行并返回结果 | 你输入命令，它生成文档 |
| **上下文影响** | 增强当前上下文 | 创建新的子任务上下文 | 创建持久化文档 |
| **持久化** | ❌ 不生成文件 | ❌ 任务完成后消失 | ✅ 生成文件到 `dev/active/` |
| **跨会话** | ❌ 会话结束即消失 | ❌ 任务完成即结束 | ✅ 文档可跨会话使用 |
| **主要用途** | 开发过程中的实时指导 | 任务执行和分析 | 任务规划和跟踪 |

---

## 使用场景对比

### 🎯 使用 Skills 的场景

#### 1. **开发过程中需要指导**
**场景**：你正在写代码，需要遵循项目的最佳实践

**示例**：
- ✅ "帮我创建一个 Express 路由"
  - `backend-dev-guidelines` 自动激活
  - 提供路由、控制器、服务的分层模式
  - 展示代码示例和最佳实践

- ✅ "我想用 MUI 创建一个表单组件"
  - `frontend-dev-guidelines` 自动激活
  - 提供 MUI v7 的正确用法
  - 展示组件模式和样式指南

**为什么用 Skills**：
- 你还在编写代码的过程中
- 需要实时参考最佳实践
- 技能会持续提供上下文，直到你完成

---

#### 2. **防止错误和反模式**
**场景**：项目有特定的规范，需要防止违反

**示例**：
- ✅ 编辑 `src/api/**/*.ts` 文件时
  - `backend-dev-guidelines` 自动激活
  - 防止使用错误的模式（如直接在路由中写业务逻辑）
  - 提醒使用正确的分层架构

- ✅ 编辑 `src/**/*.tsx` 文件时
  - `frontend-dev-guidelines` 自动激活
  - 防止使用 MUI v6 的旧 API
  - 提醒使用正确的 MUI v7 模式

**为什么用 Skills**：
- 需要在编码时实时提醒
- 防止违反项目规范
- 自动激活，无需手动调用

---

#### 3. **学习项目规范**
**场景**：新加入项目，需要了解项目的最佳实践

**示例**：
- ✅ "这个项目如何组织代码？"
  - `backend-dev-guidelines` 提供架构说明
  - 展示文件组织方式
  - 解释设计模式

**为什么用 Skills**：
- 提供持续的知识库
- 包含完整的指南和示例
- 可以随时查阅

---

### 🤖 使用 Agents 的场景

#### 1. **任务完成后需要审查**
**场景**：你已经写完了代码，需要专业审查

**示例**：
- ✅ "审查我刚写的 UserController"
  - 使用 `code-architecture-reviewer` agent
  - Agent 自主分析代码
  - 返回完整的架构审查报告
  - 指出问题并给出建议

- ✅ "检查我刚实现的认证系统是否有安全漏洞"
  - 使用 `security-guardian` agent
  - Agent 自主检查安全问题
  - 返回安全审查报告
  - 列出潜在风险和修复建议

**为什么用 Agents**：
- 任务已经完成，需要独立审查
- 需要专业的分析和报告
- Agent 会自主执行，返回完整结果

---

#### 2. **需要自主执行的复杂任务**
**场景**：任务复杂，需要多步骤处理

**示例**：
- ✅ "帮我重构这个大型组件，拆分成更小的组件"
  - 使用 `code-refactor-master` agent
  - Agent 会：
    1. 分析组件结构
    2. 识别可拆分的部分
    3. 创建新的组件文件
    4. 更新所有引用
    5. 返回重构报告

- ✅ "分析这个 API 的性能瓶颈并优化"
  - 使用 `performance-optimizer` agent
  - Agent 会：
    1. 分析性能指标
    2. 识别瓶颈
    3. 实施优化
    4. 返回优化报告

**为什么用 Agents**：
- 任务需要多个步骤
- 需要自主决策和执行
- 你只需要描述任务，Agent 会完成所有工作

---

#### 3. **需要专业分析和报告**
**场景**：需要深入的、专业的分析

**示例**：
- ✅ "设计一个新的缓存层架构"
  - 使用 `zen-architect` agent
  - Agent 会：
    1. 分析需求
    2. 设计架构方案
    3. 创建详细规格说明
    4. 返回架构设计文档

- ✅ "分析测试覆盖率并找出缺失的测试"
  - 使用 `test-coverage` agent
  - Agent 会：
    1. 分析现有测试
    2. 识别覆盖缺口
    3. 建议测试用例
    4. 返回测试分析报告

**为什么用 Agents**：
- 需要专业的分析能力
- 需要结构化的报告
- 任务有明确的输入和输出

---

#### 4. **需要系统化调试**
**场景**：遇到复杂的错误，需要系统化方法

**示例**：
- ✅ "这个错误很奇怪，帮我找出根本原因"
  - 使用 `bug-hunter` agent
  - Agent 会：
    1. 收集错误信息
    2. 提出假设
    3. 系统化测试
    4. 找出根本原因并修复

**为什么用 Agents**：
- 需要系统化的方法
- 需要自主执行多个步骤
- 需要完整的调试报告

---

## 决策树：什么时候用哪个？

```
开始：我需要帮助
    ↓
你输入的是斜杠命令吗？（如 /dev-docs）
    ├─ 是 → 使用 Commands
    │        ├─ /dev-docs → 创建任务规划文档
    │        ├─ /dev-docs-update → 更新开发文档
    │        └─ /route-research → 研究路由测试模式
    │
    └─ 否 → 你在写代码吗？
             ├─ 是 → 你需要遵循项目规范吗？
             │        ├─ 是 → 使用 Skills（自动激活）
             │        └─ 否 → 直接写代码
             │
             └─ 否 → 你的代码已经写完了吗？
                      ├─ 是 → 你需要审查/分析吗？
                      │        ├─ 是 → 使用 Agents
                      │        │        ├─ 审查代码 → code-architecture-reviewer
                      │        │        ├─ 安全检查 → security-guardian
                      │        │        ├─ 性能分析 → performance-optimizer
                      │        │        └─ 测试分析 → test-coverage
                      │        └─ 否 → 任务完成
                      │
                      └─ 否 → 你需要执行复杂任务吗？
                               ├─ 是 → 使用 Agents
                               │        ├─ 重构代码 → code-refactor-master
                               │        ├─ 设计架构 → zen-architect
                               │        ├─ 调试错误 → bug-hunter
                               │        └─ 其他任务 → 选择合适的 agent
                               └─ 否 → 你需要规划任务吗？
                                        ├─ 是 → 使用 Commands（/dev-docs）
                                        └─ 否 → 直接描述任务
```

---

## 实际工作流示例

### 场景 1：创建新功能

**阶段 1：开发中（使用 Skills）**
```
你：帮我创建一个用户注册的 API 路由
→ backend-dev-guidelines 自动激活
→ 提供路由、控制器、服务的模式
→ 你按照模式编写代码
```

**阶段 2：完成后审查（使用 Agents）**
```
你：审查我刚写的用户注册功能
→ 使用 code-architecture-reviewer agent
→ Agent 返回架构审查报告
→ 指出问题和改进建议
```

**阶段 3：安全审查（使用 Agents）**
```
你：检查这个注册功能是否有安全漏洞
→ 使用 security-guardian agent
→ Agent 返回安全审查报告
→ 列出潜在风险
```

---

### 场景 2：重构代码

**阶段 1：规划（使用 Agents）**
```
你：规划如何重构这个大型组件
→ 使用 zen-architect agent（ANALYZE 模式）
→ Agent 返回重构方案和规格说明
```

**阶段 2：执行（使用 Agents）**
```
你：按照规格执行重构
→ 使用 modular-builder agent
→ Agent 执行重构并返回结果
```

**阶段 3：清理（使用 Agents）**
```
你：任务完成了，清理一下代码库
→ 使用 post-task-cleanup agent
→ Agent 清理临时文件，确保代码库卫生
```

---

### 场景 3：调试错误

**情况 A：前端错误（使用 Skills）**
```
你：编辑 frontend/src/components/Login.tsx
→ frontend-dev-guidelines 自动激活
→ 你写代码时，skill 提供 MUI v7 的正确用法
→ 防止使用错误的 API
```

**情况 B：运行时错误（使用 Agents）**
```
你：这个错误很奇怪，帮我找出根本原因
→ 使用 bug-hunter agent
→ Agent 系统化分析错误
→ 返回调试报告和修复方案
```

---

### 场景 4：复杂任务规划（使用 Commands）

**阶段 1：规划（使用 Commands）**
```
你：/dev-docs 实现微服务架构重构
→ Command 执行：
  1. 分析当前架构
  2. 设计新的微服务架构
  3. 生成规划文档：
     - dev/active/microservices-refactor/plan.md
     - dev/active/microservices-refactor/context.md
     - dev/active/microservices-refactor/tasks.md
  4. 文档持久化，可以跨会话查看
```

**阶段 2：开发（使用 Skills）**
```
你：根据规划开始实现
→ backend-dev-guidelines 自动激活
→ 提供微服务开发的最佳实践
→ 你按照规划逐步实现
```

**阶段 3：审查（使用 Agents）**
```
你：审查第一阶段实现
→ 使用 code-architecture-reviewer agent
→ Agent 返回架构审查报告
→ 使用 security-guardian agent
→ Agent 返回安全审查报告
```

**阶段 4：更新文档（使用 Commands）**
```
你：/dev-docs-update
→ 更新任务上下文文档
→ 记录第一阶段完成状态
→ 记录关键决策
→ 更新下一步骤
```

**阶段 5：继续开发（循环 2-4）**
```
→ 继续使用 Skills 开发
→ 使用 Agents 审查
→ 使用 Commands 更新文档
→ 直到任务完成
```

---

## 关键区别总结

### Skills = "在你写代码时，我告诉你应该怎么做"
- **时机**：开发过程中
- **方式**：自动激活，提供建议
- **作用**：指导和规范
- **输出**：代码建议、模式示例
- **持久化**：❌ 不生成文件

### Agents = "你把任务给我，我帮你完成并返回结果"
- **时机**：任务需要执行时
- **方式**：手动调用（Task 工具），自主执行
- **作用**：执行和分析
- **输出**：完整的报告、修复结果
- **持久化**：❌ 任务完成后消失

### Commands = "你输入命令，我生成结构化文档用于规划"
- **时机**：开始复杂任务前或需要文档化时
- **方式**：斜杠命令（`/command`），生成文件
- **作用**：规划和跟踪
- **输出**：文档文件（plan.md, context.md, tasks.md）
- **持久化**：✅ 生成文件到 `dev/active/`，跨会话可用

---

### 💬 使用 Commands 的场景

#### 1. **开始复杂任务前需要规划**
**场景**：你要开始一个复杂的功能开发，需要详细的规划文档

**示例**：
- ✅ `/dev-docs 实现用户认证系统`
  - Command 会：
    1. 分析需求
    2. 创建详细的任务规划
    3. 生成三个文件：
       - `dev/active/user-auth-system/plan.md` - 完整规划
       - `dev/active/user-auth-system/context.md` - 上下文信息
       - `dev/active/user-auth-system/tasks.md` - 任务清单
    4. 文档持久化，可以跨会话使用

**为什么用 Commands**：
- 需要结构化的规划文档
- 需要跨会话跟踪任务
- 需要持久化的任务清单

---

#### 2. **需要跨会话继续的任务**
**场景**：任务需要多天完成，需要文档化当前状态

**示例**：
- ✅ `/dev-docs-update`
  - 更新所有活跃任务的上下文文档
  - 记录当前实现状态
  - 记录关键决策
  - 记录文件修改
  - 记录下一步骤

**为什么用 Commands**：
- 会话结束前需要保存状态
- 需要跨会话继续工作
- 需要记录关键决策和上下文

---

#### 3. **需要持久化的任务跟踪**
**场景**：复杂任务需要跟踪进度和状态

**示例**：
- ✅ `/dev-docs 重构认证系统`
  - 生成规划文档
  - 创建任务清单
  - 可以随时查看进度
  - 可以跨会话继续

**为什么用 Commands**：
- 需要持久化的任务跟踪
- 需要结构化的文档
- 需要可分享的规划文档

---

## 互补使用

**最佳实践**：Skills、Agents 和 Commands 可以配合使用

### 完整工作流示例

**阶段 1：规划（使用 Commands）**
```
你：/dev-docs 实现用户认证系统
→ Command 生成规划文档
→ dev/active/user-auth-system/plan.md
→ dev/active/user-auth-system/tasks.md
```

**阶段 2：开发（使用 Skills）**
```
你：根据规划开始实现
→ backend-dev-guidelines 自动激活
→ 提供路由、控制器、服务的模式
→ 你按照模式编写代码
```

**阶段 3：审查（使用 Agents）**
```
你：审查我刚写的认证功能
→ 使用 code-architecture-reviewer agent
→ Agent 返回审查报告
→ 使用 security-guardian agent
→ Agent 返回安全审查报告
```

**阶段 4：更新文档（使用 Commands）**
```
你：/dev-docs-update
→ 更新任务上下文文档
→ 记录实现状态和决策
→ 记录下一步骤
```

**阶段 5：继续开发（循环 2-4）**
```
→ 继续使用 Skills 开发
→ 使用 Agents 审查
→ 使用 Commands 更新文档
```

---

### 三者配合的价值

1. **Commands**：提供任务规划和跟踪
2. **Skills**：提供开发过程中的指导
3. **Agents**：提供任务完成后的审查和分析

**完整流程**：
```
Commands（规划） → Skills（开发） → Agents（审查） → Commands（更新） → 循环
```

---

## 常见误区

### ❌ 错误：用 Skills 来执行任务
```
你：帮我重构这个组件
→ Skills 激活，提供重构建议
→ 但不会实际执行重构
→ 你需要自己写代码
```

**正确做法**：
```
你：帮我重构这个组件
→ 使用 code-refactor-master agent
→ Agent 自主执行重构
→ 返回重构结果
```

---

### ❌ 错误：用 Agents 来提供日常指导
```
你：编辑 src/api/users.ts
→ 你手动调用 code-architecture-reviewer
→ 但你在写代码时，它不会自动提供建议
→ 效率低
```

**正确做法**：
```
你：编辑 src/api/users.ts
→ backend-dev-guidelines 自动激活
→ 持续提供指导和最佳实践
→ 提高开发效率
```

---

## 快速参考

| 场景 | 使用 | 原因 |
|------|------|------|
| 开始复杂任务前需要规划 | Commands | 生成结构化规划文档 |
| 需要跨会话继续的任务 | Commands | 文档持久化，可跨会话使用 |
| 需要持久化的任务跟踪 | Commands | 生成文件到 `dev/active/` |
| 正在写代码，需要参考规范 | Skills | 自动激活，实时指导 |
| 代码写完了，需要审查 | Agents | 自主分析，返回报告 |
| 需要执行复杂任务 | Agents | 多步骤处理，自主执行 |
| 需要学习项目规范 | Skills | 持续的知识库 |
| 防止违反项目规范 | Skills | 自动提醒 |
| 需要专业分析报告 | Agents | 结构化输出 |
| 遇到错误需要调试 | Agents | 系统化方法 |
| 日常开发指导 | Skills | 自动激活，无需手动调用 |
| 需要更新任务文档 | Commands | 更新开发文档 |

---

## 总结

**Skills** = 开发过程中的**实时导师**  
**Agents** = 任务完成后的**专业执行者**  
**Commands** = 任务规划和跟踪的**文档生成器**

选择原则：
- **写代码时** → Skills（自动激活，实时指导）
- **任务完成后** → Agents（自主执行，返回报告）
- **开始复杂任务前** → Commands（生成规划文档）
- **需要跨会话继续** → Commands（文档持久化）
- **需要指导** → Skills（知识库和最佳实践）
- **需要执行** → Agents（自主执行任务）
- **需要规划** → Commands（结构化文档）

---

## 技术实现对比

### Skills（技能）
- **加载方式**：加载到当前会话上下文
- **执行方式**：协作式（你主导，Claude 提供建议）
- **持久化**：❌ 会话结束即消失
- **调用方式**：自动（通过 hooks）或手动（"使用 xx skill"）

### Agents（代理）
- **加载方式**：通过 Task 工具创建新的子任务
- **执行方式**：委托式（Agent 自主执行）
- **持久化**：❌ 任务完成即结束
- **调用方式**：手动（"使用 xx agent" 或描述任务）

### Commands（斜杠命令）
- **加载方式**：执行命令文件中的指令
- **执行方式**：模板化（按照命令模板生成文档）
- **持久化**：✅ 生成文件到 `dev/active/`
- **调用方式**：斜杠命令（`/dev-docs`、`/dev-docs-update`）

---

## 核心区别总结（一句话）

- **Skills**：在你写代码时，我告诉你应该怎么做（协作式）
- **Agents**：你把任务给我，我帮你完成并返回结果（委托式）
- **Commands**：你输入命令，我生成结构化文档用于规划（模板化）

